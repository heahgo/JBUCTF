from pwn import *
from Crypto.Util.Padding import pad
from base64 import b64decode, b64encode

p = remote('172.17.0.2', 10009)
BLOCK_SIZE = 16
flag = []          # flag length : 48 byte

flag_len = 11111111111111111111111111
count = 0
for i in range(1, 17):
    p.recvuntil(b'plain text (base64) >> ')
    p.sendline(b64encode(b'A'*i))
    p.recvuntil(b'enc_data')
    result = b64decode(p.recvline()[:-1])
    if len(result) > flag_len:
        flag_len = flag_len - i
        break
    else:
        count += 0
    flag_len = len(result)
if count == 16:
    flag_len = flag_len - 17
print('flag length :', flag_len)

data = b''
for i in range(3):  
    result = b''
    for j in (range(1, 17)):
        data = b'A' * (j + BLOCK_SIZE) 
        p.recvuntil(b'plain text (base64) >> ')
        p.sendline(b64encode(data))
        p.recvuntil(b'enc_data : ')
        cipher = b64decode(p.recvline()[:-1])
        if i == 0:
            if j != 16: 
            # j = 16 일 때, 암호문의 마지막은 패딩으로 인해 0f*16 이므로 마지막 두번째 블록을 봐야함
                cipher_block = cipher[-16:]   
            else:
                cipher_block = cipher[-32:-16]      
        else:
            if j != 16:
                cipher_block = cipher[-32-BLOCK_SIZE*(i-1):-16-BLOCK_SIZE*(i-1)]
            else:
                cipher_block = cipher[-32-BLOCK_SIZE*i:-16-BLOCK_SIZE*i]
            
        for prefix in range(0x0100):
            prefix = bytes({prefix})
            if i == 0:
                payload = pad(prefix + result, BLOCK_SIZE)
            else:   
                payload = prefix + result + flag[i-1][:-len(prefix + result)]
            
            p.recvuntil(b'plain text (base64) >> ')
            p.sendline(b64encode(payload))
            p.recvuntil(b'enc_data : ')
            cipher = b64decode(p.recvline()[:-1])
            if cipher[:16] == cipher_block:
                result = prefix + result 
                break
    flag.append(result)
flag.reverse()
print(f'flag : {(flag[0] + flag[1] + flag[2]).decode()}')

